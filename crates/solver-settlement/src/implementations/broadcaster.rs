//! Broadcaster oracle settlement implementation.
//!
//! This settlement uses BroadcasterOracle `submit` + `verifyMessage` flow and
//! relies on storage proofs generated by an external prover service.

use crate::{
	utils::{
		address_to_bytes32, check_is_proven, create_providers_for_chains, parse_address_table,
		parse_b256_table, parse_oracle_config, SettlementMessageTracker,
	},
	OracleConfig, SettlementError, SettlementInterface,
};
use alloy_primitives::{hex, FixedBytes, B256, U256};
use alloy_provider::{DynProvider, Provider};
use alloy_sol_types::{sol, SolCall};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256};
use solver_storage::StorageService;
use solver_types::{
	with_0x_prefix, ConfigSchema, Field, FieldType, FillProof, InteropAddress, NetworksConfig,
	Order, OrderOutput, Schema, Transaction, TransactionHash, TransactionReceipt, TransactionType,
};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

sol! {
	struct RemoteReadArgs {
		address[] route;
		bytes[] bhpInputs;
		bytes storageProof;
	}

	interface IBroadcasterOracle {
		function submit(address source, bytes[] calldata payloads) external;

		function verifyMessage(
			RemoteReadArgs calldata broadcasterReadArgs,
			uint256 remoteChainId,
			address remoteOracle,
			bytes calldata messageData
		) external;
	}

	event MessageBroadcast(bytes32 indexed message, address indexed publisher);
}

fn now_seconds() -> u64 {
	SystemTime::now()
		.duration_since(UNIX_EPOCH)
		.map(|d| d.as_secs())
		.unwrap_or(0)
}

/// Helper to compute keccak256 hash.
fn keccak256(data: &[u8]) -> [u8; 32] {
	let mut hasher = Keccak256::new();
	hasher.update(data);
	let result = hasher.finalize();
	let mut out = [0u8; 32];
	out.copy_from_slice(&result);
	out
}

/// Convert order ID string to bytes32.
fn order_id_to_bytes32(order_id: &str) -> [u8; 32] {
	if let Some(hex_str) = order_id.strip_prefix("0x") {
		let mut bytes = [0u8; 32];
		if let Ok(decoded) = hex::decode(hex_str) {
			let len = decoded.len().min(32);
			bytes[32 - len..].copy_from_slice(&decoded[..len]);
		}
		bytes
	} else {
		let raw = order_id.as_bytes();
		let mut bytes = [0u8; 32];
		let len = raw.len().min(32);
		bytes[32 - len..].copy_from_slice(&raw[..len]);
		bytes
	}
}

/// Broadcaster-compatible output representation.
struct EncodedOutput {
	token: [u8; 32],
	amount: U256,
	recipient: [u8; 32],
	call: Vec<u8>,
	context: Vec<u8>,
}

fn interop_address_to_bytes32(addr: &InteropAddress) -> [u8; 32] {
	let mut bytes32 = [0u8; 32];
	let raw_bytes = addr.to_bytes();

	if let Ok(eth_addr) = addr.ethereum_address() {
		bytes32[12..].copy_from_slice(eth_addr.as_slice());
	} else {
		let len = raw_bytes.len().min(32);
		bytes32[32 - len..].copy_from_slice(&raw_bytes[..len]);
	}

	bytes32
}

fn order_output_to_encoded(output: &OrderOutput) -> EncodedOutput {
	EncodedOutput {
		token: interop_address_to_bytes32(&output.asset),
		amount: output.amount,
		recipient: interop_address_to_bytes32(&output.receiver),
		call: output
			.calldata
			.as_ref()
			.and_then(|s| hex::decode(s.trim_start_matches("0x")).ok())
			.unwrap_or_default(),
		context: vec![],
	}
}

fn extract_output_details(order: &Order) -> Result<EncodedOutput, SettlementError> {
	let parsed_order = order.parse_order_data().map_err(|e| {
		SettlementError::ValidationFailed(format!("Failed to parse order data: {e}"))
	})?;
	let outputs = parsed_order.parse_requested_outputs();
	let first_output = outputs
		.first()
		.ok_or_else(|| SettlementError::ValidationFailed("No outputs found in order".into()))?;
	Ok(order_output_to_encoded(first_output))
}

/// Extract (solver, timestamp) from OutputFilled logs.
fn extract_fill_details_from_logs(
	logs: &[solver_types::Log],
	order_id: &[u8; 32],
) -> Result<([u8; 32], u32), SettlementError> {
	let output_filled_signature = keccak256(
		b"OutputFilled(bytes32,bytes32,uint32,(bytes32,bytes32,uint256,bytes32,uint256,bytes32,bytes,bytes),uint256)",
	);

	for log in logs {
		if log.topics.len() >= 2 && log.topics[0].0 == output_filled_signature {
			if log.topics[1].0 == *order_id && log.data.len() >= 64 {
				let mut solver = [0u8; 32];
				solver.copy_from_slice(&log.data[0..32]);
				let timestamp_bytes = &log.data[32..64];
				let timestamp = u32::from_be_bytes([
					timestamp_bytes[28],
					timestamp_bytes[29],
					timestamp_bytes[30],
					timestamp_bytes[31],
				]);
				return Ok((solver, timestamp));
			}
		}
	}

	Err(SettlementError::ValidationFailed(
		"No OutputFilled event detected in logs".into(),
	))
}

#[allow(clippy::too_many_arguments)]
fn encode_fill_description(
	solver_identifier: [u8; 32],
	order_id: [u8; 32],
	timestamp: u32,
	token: [u8; 32],
	amount: U256,
	recipient: [u8; 32],
	call_data: Vec<u8>,
	context: Vec<u8>,
) -> Result<Vec<u8>, SettlementError> {
	if call_data.len() > u16::MAX as usize {
		return Err(SettlementError::ValidationFailed(
			"Call data too large".into(),
		));
	}
	if context.len() > u16::MAX as usize {
		return Err(SettlementError::ValidationFailed(
			"Context data too large".into(),
		));
	}

	let mut payload =
		Vec::with_capacity(32 + 32 + 4 + 32 + 32 + 32 + 2 + call_data.len() + 2 + context.len());
	payload.extend_from_slice(&solver_identifier);
	payload.extend_from_slice(&order_id);
	payload.extend_from_slice(&timestamp.to_be_bytes());
	payload.extend_from_slice(&token);
	payload.extend_from_slice(&amount.to_be_bytes::<32>());
	payload.extend_from_slice(&recipient);
	payload.extend_from_slice(&(call_data.len() as u16).to_be_bytes());
	payload.extend_from_slice(&call_data);
	payload.extend_from_slice(&(context.len() as u16).to_be_bytes());
	payload.extend_from_slice(&context);
	Ok(payload)
}

fn encode_message_data(
	application: [u8; 32],
	payloads: &[Vec<u8>],
) -> Result<Vec<u8>, SettlementError> {
	if payloads.len() > u16::MAX as usize {
		return Err(SettlementError::ValidationFailed(
			"Too many payloads for message encoding".into(),
		));
	}

	let mut encoded = Vec::new();
	encoded.extend_from_slice(&application);
	encoded.extend_from_slice(&(payloads.len() as u16).to_be_bytes());

	for payload in payloads {
		if payload.len() > u16::MAX as usize {
			return Err(SettlementError::ValidationFailed(
				"Payload too large for message encoding".into(),
			));
		}
		encoded.extend_from_slice(&(payload.len() as u16).to_be_bytes());
		encoded.extend_from_slice(payload);
	}

	Ok(encoded)
}

fn hash_payload_hashes(payload_hashes: &[[u8; 32]]) -> [u8; 32] {
	let mut bytes = Vec::with_capacity(payload_hashes.len() * 32);
	for payload_hash in payload_hashes {
		bytes.extend_from_slice(payload_hash);
	}
	keccak256(&bytes)
}

fn compute_broadcaster_message(source: &solver_types::Address, payloads: &[Vec<u8>]) -> [u8; 32] {
	let payload_hashes: Vec<[u8; 32]> = payloads.iter().map(|payload| keccak256(payload)).collect();
	let payload_hashes_digest = hash_payload_hashes(&payload_hashes);

	// keccak256(abi.encode(address, bytes32))
	let mut encoded = [0u8; 64];
	encoded[12..32].copy_from_slice(&source.0);
	encoded[32..64].copy_from_slice(&payload_hashes_digest);
	keccak256(&encoded)
}

fn compute_message_slot(message: [u8; 32], publisher: &solver_types::Address) -> [u8; 32] {
	// keccak256(abi.encode(message, publisher))
	let mut encoded = [0u8; 64];
	encoded[0..32].copy_from_slice(&message);
	encoded[44..64].copy_from_slice(&publisher.0);
	keccak256(&encoded)
}

fn parse_hex_bytes(label: &str, value: &str) -> Result<Vec<u8>, SettlementError> {
	hex::decode(value.trim_start_matches("0x"))
		.map_err(|e| SettlementError::ValidationFailed(format!("Invalid hex for {label}: {e}")))
}

fn parse_u64_table(table: &toml::Value) -> Result<HashMap<u64, u64>, SettlementError> {
	let mut result = HashMap::new();
	if let Some(table) = table.as_table() {
		for (chain_id_str, value) in table {
			let chain_id = chain_id_str.parse::<u64>().map_err(|e| {
				SettlementError::ValidationFailed(format!("Invalid chain ID '{chain_id_str}': {e}"))
			})?;
			let parsed = value.as_integer().ok_or_else(|| {
				SettlementError::ValidationFailed(format!(
					"Integer value required for chain {chain_id}"
				))
			})? as u64;
			result.insert(chain_id, parsed);
		}
	}
	Ok(result)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct BroadcasterSubmission {
	source_chain: u64,
	destination_chain: u64,
	submission_tx_hash: TransactionHash,
	submission_timestamp: u64,
	#[serde(with = "hex::serde")]
	payload_hash: [u8; 32],
	#[serde(with = "hex::serde")]
	message: [u8; 32],
	message_data: Vec<u8>,
	application: solver_types::Address,
	remote_oracle: solver_types::Address,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct BroadcasterProofData {
	route: Vec<solver_types::Address>,
	bhp_inputs: Vec<Vec<u8>>,
	storage_proof: Vec<u8>,
	generated_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct VerifiedMessage {
	verified_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct BroadcasterMessageState {
	submission: Option<BroadcasterSubmission>,
	proof: Option<BroadcasterProofData>,
	verified: Option<VerifiedMessage>,
}

#[derive(Clone)]
struct BroadcasterMessageTracker {
	tracker: SettlementMessageTracker<BroadcasterMessageState>,
}

impl BroadcasterMessageTracker {
	fn new(storage: Arc<StorageService>) -> Self {
		Self {
			tracker: SettlementMessageTracker::new(storage, "broadcaster"),
		}
	}

	async fn load(&self, order_id: &str) -> Option<BroadcasterMessageState> {
		self.tracker.load(order_id).await
	}

	async fn save(
		&self,
		order_id: &str,
		state: &BroadcasterMessageState,
	) -> Result<(), SettlementError> {
		let ttl = if state.verified.is_some() {
			Some(Duration::from_secs(7 * 24 * 60 * 60))
		} else {
			None
		};
		self.tracker.save(order_id, state, ttl).await
	}

	async fn track_submission(
		&self,
		order_id: &str,
		submission: BroadcasterSubmission,
	) -> Result<(), SettlementError> {
		let mut state = self
			.load(order_id)
			.await
			.unwrap_or(BroadcasterMessageState {
				submission: None,
				proof: None,
				verified: None,
			});
		state.submission = Some(submission);
		state.proof = None;
		self.save(order_id, &state).await
	}

	async fn store_proof(
		&self,
		order_id: &str,
		proof: BroadcasterProofData,
	) -> Result<(), SettlementError> {
		let mut state = self
			.load(order_id)
			.await
			.unwrap_or(BroadcasterMessageState {
				submission: None,
				proof: None,
				verified: None,
			});
		state.proof = Some(proof);
		self.save(order_id, &state).await
	}

	async fn mark_verified(&self, order_id: &str) -> Result<(), SettlementError> {
		let mut state = self
			.load(order_id)
			.await
			.unwrap_or(BroadcasterMessageState {
				submission: None,
				proof: None,
				verified: None,
			});
		state.verified = Some(VerifiedMessage {
			verified_at: now_seconds(),
		});
		self.save(order_id, &state).await
	}
}

#[derive(Debug, Serialize)]
struct ProofRequest {
	remote_chain_id: u64,
	local_chain_id: u64,
	broadcaster_address: String,
	receiver_address: String,
	publisher: String,
	message: String,
	message_slot: String,
	broadcaster_id: String,
}

#[derive(Debug, Deserialize)]
struct ProofResponse {
	route: Vec<String>,
	#[serde(alias = "bhpInputs")]
	bhp_inputs: Vec<String>,
	#[serde(alias = "storageProof")]
	storage_proof: String,
}

/// Broadcaster settlement implementation.
pub struct BroadcasterSettlement {
	providers: HashMap<u64, DynProvider>,
	oracle_config: OracleConfig,
	broadcaster_addresses: HashMap<u64, solver_types::Address>,
	receiver_addresses: HashMap<u64, solver_types::Address>,
	broadcaster_ids: HashMap<u64, B256>,
	proof_service_url: String,
	proof_wait_time_seconds: u64,
	storage_proof_timeout_seconds: u64,
	default_finality_blocks: u64,
	finality_blocks: HashMap<u64, u64>,
	message_tracker: Arc<BroadcasterMessageTracker>,
	http_client: reqwest::Client,
}

impl BroadcasterSettlement {
	#[allow(clippy::too_many_arguments)]
	pub async fn new(
		networks: &NetworksConfig,
		oracle_config: OracleConfig,
		broadcaster_addresses: HashMap<u64, solver_types::Address>,
		receiver_addresses: HashMap<u64, solver_types::Address>,
		broadcaster_ids: HashMap<u64, B256>,
		proof_service_url: String,
		proof_wait_time_seconds: u64,
		storage_proof_timeout_seconds: u64,
		default_finality_blocks: u64,
		finality_blocks: HashMap<u64, u64>,
		storage: Arc<StorageService>,
	) -> Result<Self, SettlementError> {
		let mut all_network_ids: Vec<u64> = oracle_config
			.input_oracles
			.keys()
			.chain(oracle_config.output_oracles.keys())
			.copied()
			.collect();

		for chain_id in broadcaster_addresses.keys() {
			all_network_ids.push(*chain_id);
		}
		for chain_id in receiver_addresses.keys() {
			all_network_ids.push(*chain_id);
		}

		let providers = create_providers_for_chains(&all_network_ids, networks)?;

		// Validate broadcaster config coverage for configured routes.
		for (source_chain, destination_chains) in &oracle_config.routes {
			if !receiver_addresses.contains_key(source_chain) {
				return Err(SettlementError::ValidationFailed(format!(
					"Receiver address not configured for source chain {source_chain}"
				)));
			}

			for destination_chain in destination_chains {
				if !broadcaster_addresses.contains_key(destination_chain) {
					return Err(SettlementError::ValidationFailed(format!(
						"Broadcaster address not configured for destination chain {destination_chain}"
					)));
				}
				if !broadcaster_ids.contains_key(destination_chain) {
					return Err(SettlementError::ValidationFailed(format!(
						"Broadcaster ID not configured for remote chain {destination_chain}"
					)));
				}
			}
		}

		let http_client = reqwest::Client::builder()
			.timeout(Duration::from_secs(storage_proof_timeout_seconds))
			.build()
			.map_err(|e| {
				SettlementError::ValidationFailed(format!("Failed to build HTTP client: {e}"))
			})?;

		Ok(Self {
			providers,
			oracle_config,
			broadcaster_addresses,
			receiver_addresses,
			broadcaster_ids,
			proof_service_url,
			proof_wait_time_seconds,
			storage_proof_timeout_seconds,
			default_finality_blocks,
			finality_blocks,
			message_tracker: Arc::new(BroadcasterMessageTracker::new(storage)),
			http_client,
		})
	}

	fn source_and_destination_chain(order: &Order) -> Result<(u64, u64), SettlementError> {
		let source_chain = order
			.input_chains
			.first()
			.map(|c| c.chain_id)
			.ok_or_else(|| SettlementError::ValidationFailed("No input chains in order".into()))?;
		let destination_chain = order
			.output_chains
			.first()
			.map(|c| c.chain_id)
			.ok_or_else(|| SettlementError::ValidationFailed("No output chains in order".into()))?;
		Ok((source_chain, destination_chain))
	}

	fn finality_blocks_for(&self, chain_id: u64) -> u64 {
		self.finality_blocks
			.get(&chain_id)
			.copied()
			.unwrap_or(self.default_finality_blocks)
	}

	fn proof_endpoint(&self) -> String {
		format!(
			"{}/v1/broadcaster/proof",
			self.proof_service_url.trim_end_matches('/')
		)
	}

	fn parse_fill_payload_from_logs(
		&self,
		order: &Order,
		logs: &[solver_types::Log],
	) -> Result<Vec<u8>, SettlementError> {
		let output = extract_output_details(order)?;
		let order_id_bytes = order_id_to_bytes32(&order.id);
		let (solver_identifier, fill_timestamp) =
			extract_fill_details_from_logs(logs, &order_id_bytes)?;

		encode_fill_description(
			solver_identifier,
			order_id_bytes,
			fill_timestamp,
			output.token,
			output.amount,
			output.recipient,
			output.call,
			output.context,
		)
	}

	async fn fetch_fill_receipt_logs(
		&self,
		order: &Order,
		destination_chain: u64,
	) -> Result<Vec<solver_types::Log>, SettlementError> {
		let fill_tx_hash = order.fill_tx_hash.as_ref().ok_or_else(|| {
			SettlementError::ValidationFailed(
				"Missing fill transaction hash: required for broadcaster payload tracking".into(),
			)
		})?;

		let provider = self.providers.get(&destination_chain).ok_or_else(|| {
			SettlementError::ValidationFailed(format!("No provider for chain {destination_chain}"))
		})?;

		let receipt = provider
			.get_transaction_receipt(FixedBytes::<32>::from_slice(&fill_tx_hash.0))
			.await
			.map_err(|e| {
				SettlementError::ValidationFailed(format!("Failed to get fill receipt: {e}"))
			})?
			.ok_or_else(|| {
				SettlementError::ValidationFailed("Fill transaction not found".to_string())
			})?;

		let logs: Vec<solver_types::Log> = receipt
			.inner
			.logs()
			.iter()
			.map(|log| solver_types::Log {
				address: solver_types::Address(log.address().0 .0.to_vec()),
				topics: log
					.topics()
					.iter()
					.map(|topic| solver_types::H256(topic.0))
					.collect(),
				data: log.data().data.to_vec(),
			})
			.collect();

		Ok(logs)
	}

	fn extract_message_from_broadcast_logs(
		&self,
		logs: &[solver_types::Log],
		expected_publisher: &solver_types::Address,
	) -> Option<[u8; 32]> {
		let signature = keccak256(b"MessageBroadcast(bytes32,address)");
		for log in logs {
			if log.topics.len() < 3 {
				continue;
			}
			if log.topics[0].0 != signature {
				continue;
			}

			let publisher_topic = log.topics[2].0;
			let publisher = solver_types::Address(publisher_topic[12..].to_vec());
			if &publisher == expected_publisher {
				return Some(log.topics[1].0);
			}
		}
		None
	}

	async fn generate_and_store_proof(
		&self,
		order: &Order,
		source_chain: u64,
		destination_chain: u64,
		submission: &BroadcasterSubmission,
	) -> Result<(), SettlementError> {
		let broadcaster_address = self
			.broadcaster_addresses
			.get(&destination_chain)
			.ok_or_else(|| {
				SettlementError::ValidationFailed(format!(
					"No broadcaster configured for chain {destination_chain}"
				))
			})?;

		let receiver_address = self.receiver_addresses.get(&source_chain).ok_or_else(|| {
			SettlementError::ValidationFailed(format!(
				"No receiver configured for chain {source_chain}"
			))
		})?;

		let broadcaster_id = self
			.broadcaster_ids
			.get(&destination_chain)
			.ok_or_else(|| {
				SettlementError::ValidationFailed(format!(
					"No broadcaster ID configured for chain {destination_chain}"
				))
			})?;

		let message_slot = compute_message_slot(submission.message, &submission.remote_oracle);

		let request_payload = ProofRequest {
			remote_chain_id: destination_chain,
			local_chain_id: source_chain,
			broadcaster_address: with_0x_prefix(&hex::encode(&broadcaster_address.0)),
			receiver_address: with_0x_prefix(&hex::encode(&receiver_address.0)),
			publisher: with_0x_prefix(&hex::encode(&submission.remote_oracle.0)),
			message: with_0x_prefix(&hex::encode(submission.message)),
			message_slot: with_0x_prefix(&hex::encode(message_slot)),
			broadcaster_id: broadcaster_id.to_string(),
		};

		let response = self
			.http_client
			.post(self.proof_endpoint())
			.json(&request_payload)
			.send()
			.await
			.map_err(|e| SettlementError::ProofGenerationFailed {
				source_chain: destination_chain,
				reason: format!("proof service request failed: {e}"),
			})?;

		if !response.status().is_success() {
			let status = response.status();
			let body = response.text().await.unwrap_or_default();
			return Err(SettlementError::ProofGenerationFailed {
				source_chain: destination_chain,
				reason: format!("proof service returned {status}: {body}"),
			});
		}

		let proof_response: ProofResponse =
			response
				.json()
				.await
				.map_err(|e| SettlementError::ProofGenerationFailed {
					source_chain: destination_chain,
					reason: format!("invalid proof response payload: {e}"),
				})?;

		let route: Vec<solver_types::Address> = proof_response
			.route
			.iter()
			.map(|address| {
				solver_types::utils::parse_address(address).map_err(|e| {
					SettlementError::ProofGenerationFailed {
						source_chain: destination_chain,
						reason: format!("invalid route address '{address}': {e}"),
					}
				})
			})
			.collect::<Result<_, _>>()?;

		let bhp_inputs: Vec<Vec<u8>> = proof_response
			.bhp_inputs
			.iter()
			.map(|value| {
				parse_hex_bytes("bhp_inputs", value).map_err(|e| {
					SettlementError::ProofGenerationFailed {
						source_chain: destination_chain,
						reason: e.to_string(),
					}
				})
			})
			.collect::<Result<_, _>>()?;

		let storage_proof = parse_hex_bytes("storage_proof", &proof_response.storage_proof)
			.map_err(|e| SettlementError::ProofGenerationFailed {
				source_chain: destination_chain,
				reason: e.to_string(),
			})?;

		if route.is_empty() || route.len() != bhp_inputs.len() {
			return Err(SettlementError::ProofGenerationFailed {
				source_chain: destination_chain,
				reason: "route/bhp_inputs length mismatch".into(),
			});
		}

		self.message_tracker
			.store_proof(
				&order.id,
				BroadcasterProofData {
					route,
					bhp_inputs,
					storage_proof,
					generated_at: now_seconds(),
				},
			)
			.await
	}
}

/// Configuration schema for broadcaster settlement.
pub struct BroadcasterSettlementSchema;

impl BroadcasterSettlementSchema {
	pub fn validate_config(config: &toml::Value) -> Result<(), solver_types::ValidationError> {
		let instance = Self;
		instance.validate(config)
	}
}

impl ConfigSchema for BroadcasterSettlementSchema {
	fn validate(&self, config: &toml::Value) -> Result<(), solver_types::ValidationError> {
		let schema = Schema::new(
			vec![
				Field::new(
					"oracles",
					FieldType::Table(Schema::new(
						vec![
							Field::new("input", FieldType::Table(Schema::new(vec![], vec![]))),
							Field::new("output", FieldType::Table(Schema::new(vec![], vec![]))),
						],
						vec![],
					)),
				),
				Field::new("routes", FieldType::Table(Schema::new(vec![], vec![]))),
				Field::new(
					"broadcaster_addresses",
					FieldType::Table(Schema::new(vec![], vec![])),
				),
				Field::new(
					"receiver_addresses",
					FieldType::Table(Schema::new(vec![], vec![])),
				),
				Field::new(
					"broadcaster_ids",
					FieldType::Table(Schema::new(vec![], vec![])),
				),
				Field::new("proof_service_url", FieldType::String),
			],
			vec![
				Field::new("oracle_selection_strategy", FieldType::String),
				Field::new(
					"proof_wait_time_seconds",
					FieldType::Integer {
						min: Some(0),
						max: Some(3600),
					},
				),
				Field::new(
					"storage_proof_timeout_seconds",
					FieldType::Integer {
						min: Some(1),
						max: Some(300),
					},
				),
				Field::new(
					"default_finality_blocks",
					FieldType::Integer {
						min: Some(1),
						max: Some(10000),
					},
				),
				Field::new(
					"finality_blocks",
					FieldType::Table(Schema::new(vec![], vec![])),
				),
			],
		);
		schema.validate(config)
	}
}

#[async_trait]
impl SettlementInterface for BroadcasterSettlement {
	fn oracle_config(&self) -> &OracleConfig {
		&self.oracle_config
	}

	fn config_schema(&self) -> Box<dyn ConfigSchema> {
		Box::new(BroadcasterSettlementSchema)
	}

	async fn get_attestation(
		&self,
		order: &Order,
		tx_hash: &TransactionHash,
	) -> Result<FillProof, SettlementError> {
		let (source_chain, destination_chain) = Self::source_and_destination_chain(order)?;
		let provider = self.providers.get(&destination_chain).ok_or_else(|| {
			SettlementError::ValidationFailed(format!(
				"No provider configured for chain {destination_chain}"
			))
		})?;

		let oracle_addresses = self.get_input_oracles(source_chain);
		if oracle_addresses.is_empty() {
			return Err(SettlementError::ValidationFailed(format!(
				"No input oracle configured for chain {source_chain}"
			)));
		}

		let order_id_hash = keccak256(order.id.as_bytes());
		let selection_context =
			u64::from_be_bytes(order_id_hash[0..8].try_into().map_err(|_| {
				SettlementError::ValidationFailed("Failed to convert hash bytes".to_string())
			})?);
		let oracle_address = self
			.select_oracle(&oracle_addresses, Some(selection_context))
			.ok_or_else(|| {
				SettlementError::ValidationFailed(format!(
					"Failed to select oracle for chain {source_chain}"
				))
			})?;

		let receipt = provider
			.get_transaction_receipt(FixedBytes::<32>::from_slice(&tx_hash.0))
			.await
			.map_err(|e| SettlementError::ValidationFailed(format!("Failed to get receipt: {e}")))?
			.ok_or_else(|| {
				SettlementError::ValidationFailed("Transaction not found".to_string())
			})?;

		if !receipt.status() {
			return Err(SettlementError::ValidationFailed(
				"Transaction failed".to_string(),
			));
		}

		let tx_block = receipt.block_number.unwrap_or(0);
		let block = provider
			.get_block_by_number(alloy_rpc_types::BlockNumberOrTag::Number(tx_block))
			.await
			.map_err(|e| SettlementError::ValidationFailed(format!("Failed to get block: {e}")))?;

		let block_timestamp = block
			.ok_or_else(|| SettlementError::ValidationFailed("Block not found".to_string()))?
			.header
			.timestamp;

		Ok(FillProof {
			tx_hash: tx_hash.clone(),
			block_number: tx_block,
			oracle_address: with_0x_prefix(&hex::encode(&oracle_address.0)),
			attestation_data: None,
			filled_timestamp: block_timestamp,
		})
	}

	async fn can_claim(&self, order: &Order, fill_proof: &FillProof) -> bool {
		let (source_chain, destination_chain) = match Self::source_and_destination_chain(order) {
			Ok(chains) => chains,
			Err(e) => {
				tracing::error!(order_id = %order.id, error = %e, "Invalid order chains");
				return false;
			},
		};

		let state = match self.message_tracker.load(&order.id).await {
			Some(state) => state,
			None => {
				tracing::debug!(order_id = %order.id, "No broadcaster submission state yet");
				return false;
			},
		};

		let submission = match state.submission.as_ref() {
			Some(submission) => submission,
			None => return false,
		};

		let input_oracle = match self.select_oracle(&self.get_input_oracles(source_chain), None) {
			Some(oracle) => oracle,
			None => return false,
		};
		let output_oracle =
			match self.select_oracle(&self.get_output_oracles(destination_chain), None) {
				Some(oracle) => oracle,
				None => return false,
			};

		let provider = match self.providers.get(&source_chain) {
			Some(provider) => provider,
			None => return false,
		};

		let remote_oracle = address_to_bytes32(&output_oracle);
		let application = address_to_bytes32(&submission.application);
		let is_proven = match check_is_proven(
			provider,
			&input_oracle,
			destination_chain,
			remote_oracle,
			application,
			submission.payload_hash,
		)
		.await
		{
			Ok(proven) => proven,
			Err(e) => {
				tracing::debug!(order_id = %order.id, error = %e, "isProven check failed");
				return false;
			},
		};

		if is_proven {
			if let Err(e) = self.message_tracker.mark_verified(&order.id).await {
				tracing::warn!(order_id = %order.id, error = %e, "Failed to persist verified status");
			}
			return true;
		}

		// Wait a minimum time before proof generation.
		let now = now_seconds();
		if now
			< fill_proof
				.filled_timestamp
				.saturating_add(self.proof_wait_time_seconds)
		{
			return false;
		}

		// Wait for chain finality before generating proofs.
		let destination_provider = match self.providers.get(&destination_chain) {
			Some(provider) => provider,
			None => return false,
		};
		let current_destination_block = match destination_provider.get_block_number().await {
			Ok(block) => block,
			Err(_) => return false,
		};
		let required_finality_block = fill_proof
			.block_number
			.saturating_add(self.finality_blocks_for(destination_chain));
		if current_destination_block < required_finality_block {
			return false;
		}

		// Proof already available and ready to submit.
		if state.proof.is_some() {
			return true;
		}

		// Try proof generation in the monitor loop; return false if unavailable so we retry.
		match self
			.generate_and_store_proof(order, source_chain, destination_chain, submission)
			.await
		{
			Ok(_) => true,
			Err(e) => {
				tracing::warn!(
					order_id = %order.id,
					error = %e,
					timeout_secs = self.storage_proof_timeout_seconds,
					"Broadcaster proof generation not ready"
				);
				false
			},
		}
	}

	async fn generate_post_fill_transaction(
		&self,
		order: &Order,
		fill_receipt: &TransactionReceipt,
	) -> Result<Option<Transaction>, SettlementError> {
		let (_, destination_chain) = Self::source_and_destination_chain(order)?;

		let output_oracles = self.get_output_oracles(destination_chain);
		if output_oracles.is_empty() {
			return Ok(None);
		}
		let output_oracle = self
			.select_oracle(&output_oracles, None)
			.ok_or_else(|| SettlementError::ValidationFailed("Failed to select oracle".into()))?;

		let output_settler = order
			.output_chains
			.first()
			.ok_or_else(|| SettlementError::ValidationFailed("No output chain".into()))?
			.settler_address
			.clone();

		let fill_payload = self.parse_fill_payload_from_logs(order, &fill_receipt.logs)?;
		let payloads = vec![fill_payload];

		let call_data = IBroadcasterOracle::submitCall {
			source: alloy_primitives::Address::from_slice(&output_settler.0),
			payloads: payloads.into_iter().map(Into::into).collect(),
		};

		Ok(Some(Transaction {
			to: Some(output_oracle),
			data: call_data.abi_encode(),
			value: U256::ZERO,
			chain_id: destination_chain,
			nonce: None,
			gas_limit: Some(500000),
			gas_price: None,
			max_fee_per_gas: None,
			max_priority_fee_per_gas: None,
		}))
	}

	async fn generate_pre_claim_transaction(
		&self,
		order: &Order,
		_fill_proof: &FillProof,
	) -> Result<Option<Transaction>, SettlementError> {
		let (source_chain, destination_chain) = Self::source_and_destination_chain(order)?;

		let input_oracle = self
			.select_oracle(&self.get_input_oracles(source_chain), None)
			.ok_or_else(|| {
				SettlementError::ValidationFailed(format!(
					"No input oracle configured for chain {source_chain}"
				))
			})?;
		let output_oracle = self
			.select_oracle(&self.get_output_oracles(destination_chain), None)
			.ok_or_else(|| {
				SettlementError::ValidationFailed(format!(
					"No output oracle configured for chain {destination_chain}"
				))
			})?;

		let state = self.message_tracker.load(&order.id).await.ok_or_else(|| {
			SettlementError::ValidationFailed("No broadcaster state found".into())
		})?;
		let submission = state
			.submission
			.ok_or_else(|| SettlementError::ValidationFailed("No submission state found".into()))?;

		// If already proven, no pre-claim tx needed.
		let provider = self.providers.get(&source_chain).ok_or_else(|| {
			SettlementError::ValidationFailed(format!("No provider for chain {source_chain}"))
		})?;
		if check_is_proven(
			provider,
			&input_oracle,
			destination_chain,
			address_to_bytes32(&output_oracle),
			address_to_bytes32(&submission.application),
			submission.payload_hash,
		)
		.await
		.unwrap_or(false)
		{
			return Ok(None);
		}

		let proof = state
			.proof
			.ok_or_else(|| SettlementError::ValidationFailed("No generated proof found".into()))?;

		let read_args = RemoteReadArgs {
			route: proof
				.route
				.iter()
				.map(|address| alloy_primitives::Address::from_slice(&address.0))
				.collect(),
			bhpInputs: proof.bhp_inputs.into_iter().map(Into::into).collect(),
			storageProof: proof.storage_proof.into(),
		};

		let call_data = IBroadcasterOracle::verifyMessageCall {
			broadcasterReadArgs: read_args,
			remoteChainId: U256::from(destination_chain),
			remoteOracle: alloy_primitives::Address::from_slice(&output_oracle.0),
			messageData: submission.message_data.into(),
		};

		Ok(Some(Transaction {
			to: Some(input_oracle),
			data: call_data.abi_encode(),
			value: U256::ZERO,
			chain_id: source_chain,
			nonce: None,
			gas_limit: Some(1200000),
			gas_price: None,
			max_fee_per_gas: None,
			max_priority_fee_per_gas: None,
		}))
	}

	async fn handle_transaction_confirmed(
		&self,
		order: &Order,
		tx_type: TransactionType,
		receipt: &TransactionReceipt,
	) -> Result<(), SettlementError> {
		match tx_type {
			TransactionType::PostFill => {
				let (source_chain, destination_chain) = Self::source_and_destination_chain(order)?;
				let output_oracle = self
					.select_oracle(&self.get_output_oracles(destination_chain), None)
					.ok_or_else(|| {
						SettlementError::ValidationFailed(format!(
							"No output oracle configured for chain {destination_chain}"
						))
					})?;

				let output_settler = order
					.output_chains
					.first()
					.ok_or_else(|| SettlementError::ValidationFailed("No output chain".into()))?
					.settler_address
					.clone();

				let fill_logs = self
					.fetch_fill_receipt_logs(order, destination_chain)
					.await?;
				let fill_payload = self.parse_fill_payload_from_logs(order, &fill_logs)?;
				let payload_hash = keccak256(&fill_payload);
				let payloads = vec![fill_payload];

				let message_data =
					encode_message_data(address_to_bytes32(&output_settler), &payloads)?;
				let computed_message = compute_broadcaster_message(&output_settler, &payloads);
				if let Some(actual_message) =
					self.extract_message_from_broadcast_logs(&receipt.logs, &output_oracle)
				{
					if actual_message != computed_message {
						return Err(SettlementError::SlotDerivationMismatch);
					}
				}

				self.message_tracker
					.track_submission(
						&order.id,
						BroadcasterSubmission {
							source_chain,
							destination_chain,
							submission_tx_hash: receipt.hash.clone(),
							submission_timestamp: now_seconds(),
							payload_hash,
							message: computed_message,
							message_data,
							application: output_settler,
							remote_oracle: output_oracle,
						},
					)
					.await?;
			},
			TransactionType::PreClaim => {
				self.message_tracker.mark_verified(&order.id).await?;
			},
			_ => {},
		}

		Ok(())
	}
}

/// Factory function to create a broadcaster settlement provider from configuration.
pub fn create_settlement(
	config: &toml::Value,
	networks: &NetworksConfig,
	storage: Arc<StorageService>,
) -> Result<Box<dyn SettlementInterface>, SettlementError> {
	BroadcasterSettlementSchema::validate_config(config)
		.map_err(|e| SettlementError::ValidationFailed(format!("Invalid configuration: {e}")))?;

	let oracle_config = parse_oracle_config(config)?;
	let broadcaster_addresses =
		parse_address_table(config.get("broadcaster_addresses").ok_or_else(|| {
			SettlementError::ValidationFailed("Missing broadcaster_addresses".to_string())
		})?)?;
	let receiver_addresses =
		parse_address_table(config.get("receiver_addresses").ok_or_else(|| {
			SettlementError::ValidationFailed("Missing receiver_addresses".to_string())
		})?)?;
	let broadcaster_ids = parse_b256_table(config.get("broadcaster_ids").ok_or_else(|| {
		SettlementError::ValidationFailed("Missing broadcaster_ids".to_string())
	})?)?;

	let proof_service_url = config
		.get("proof_service_url")
		.and_then(|value| value.as_str())
		.ok_or_else(|| SettlementError::ValidationFailed("Missing proof_service_url".into()))?
		.to_string();

	let proof_wait_time_seconds = config
		.get("proof_wait_time_seconds")
		.and_then(|value| value.as_integer())
		.unwrap_or(30) as u64;
	let storage_proof_timeout_seconds = config
		.get("storage_proof_timeout_seconds")
		.and_then(|value| value.as_integer())
		.unwrap_or(30) as u64;
	let default_finality_blocks = config
		.get("default_finality_blocks")
		.and_then(|value| value.as_integer())
		.unwrap_or(20) as u64;
	let empty_finality_table = toml::Value::Table(toml::map::Map::new());
	let finality_table = config
		.get("finality_blocks")
		.unwrap_or(&empty_finality_table);
	let finality_blocks = parse_u64_table(finality_table)?;

	let settlement = tokio::task::block_in_place(|| {
		tokio::runtime::Handle::current().block_on(async {
			BroadcasterSettlement::new(
				networks,
				oracle_config,
				broadcaster_addresses,
				receiver_addresses,
				broadcaster_ids,
				proof_service_url,
				proof_wait_time_seconds,
				storage_proof_timeout_seconds,
				default_finality_blocks,
				finality_blocks,
				storage,
			)
			.await
		})
	})?;

	Ok(Box::new(settlement))
}

/// Registry for broadcaster settlement implementation.
pub struct Registry;

impl solver_types::ImplementationRegistry for Registry {
	const NAME: &'static str = "broadcaster";
	type Factory = crate::SettlementFactory;

	fn factory() -> Self::Factory {
		create_settlement
	}
}

impl crate::SettlementRegistry for Registry {}
